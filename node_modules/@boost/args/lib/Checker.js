'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var levenary = require('levenary');

var ArgsError = require('./ArgsError.js');

var constants = require('./constants.js');

var ParseError = require('./ParseError.js');

var ValidationError = require('./ValidationError.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var levenary__default = /*#__PURE__*/_interopDefault(levenary);

class Checker {
  constructor(options) {
    this.arg = '';
    this.argIndex = 0;
    this.options = void 0;
    this.parseErrors = [];
    this.validationErrors = [];
    this.options = options;
  }

  checkCommandOrder(anotherCommand, providedCommand, paramsLength) {
    if (providedCommand !== '') {
      this.logFailureError('COMMAND_PROVIDED', [providedCommand, anotherCommand]);
    } else if (paramsLength !== 0) {
      this.logFailureError('COMMAND_NOT_FIRST');
    }
  }

  checkNoInlineValue(inlineValue) {
    if (inlineValue !== undefined) {
      this.logFailureError('VALUE_NO_INLINE');
    }
  }

  checkUnknownOption(option) {
    const guess = levenary__default['default'](option, Object.keys(this.options));

    if (guess) {
      this.logFailureError('OPTION_UNKNOWN_MORE', [option, guess]);
    } else {
      this.logFailureError('OPTION_UNKNOWN', [option]);
    }
  }

  validateArityIsMet(option, config, value) {
    if (!config.arity || !Array.isArray(value)) {
      return;
    }

    if (value.length > 0 && value.length !== config.arity) {
      this.logInvalidError('VALUE_INVALID_ARITY', [config.arity, value.length], option);
    }
  }

  validateDefaultValue(option, value, config) {
    if (config.multiple) {
      if (!Array.isArray(value)) {
        this.logInvalidError('VALUE_NON_ARRAY', [option], option);
      }

      return;
    }

    if (config.type === 'boolean' && typeof value !== 'boolean') {
      this.logInvalidError('VALUE_NON_BOOL', [option], option);
    }

    if (config.type === 'number' && typeof value !== 'number') {
      this.logInvalidError('VALUE_NON_NUMBER', [option], option);
    }

    if (config.type === 'string' && typeof value !== 'string') {
      this.logInvalidError('VALUE_NON_STRING', [option], option);
    }
  }

  validateChoiceIsMet(option, config, value) {
    if (value && Array.isArray(config.choices) && !config.choices.includes(value)) {
      this.logInvalidError('VALUE_INVALID_CHOICE', [config.choices.join(', '), value || '""'], option);
    }
  }

  validateCommandFormat(command) {
    if (!constants.COMMAND_FORMAT.test(command)) {
      this.logInvalidError('COMMAND_INVALID_FORMAT', [command]);
    }
  }

  validateNumberCount(option, config) {
    if (config.count && config.type !== 'number') {
      this.logInvalidError('OPTION_INVALID_COUNT_TYPE', [], option);
    }
  }

  validateParsedOption(option, config, value) {
    if (config.validate) {
      try {
        config.validate(value);
      } catch (error) {
        this.logInvalid(error.message, option);
      }
    }
  }

  validateParsedParam(config, value) {
    if (config.validate) {
      try {
        config.validate(value);
      } catch (error) {
        this.logInvalid(error.message);
      }
    }

    if (config.required && value === undefined) {
      this.logInvalidError('PARAM_REQUIRED', [config.label]);
    }
  }

  validateParamOrder(configs) {
    const optionals = [];
    configs.forEach(config => {
      if (config.required) {
        if (optionals.length > 0) {
          const labels = optionals.map(opt => `"${opt.label}"`);
          this.logInvalidError('PARAM_INVALID_ORDER', [labels.join(', '), config.label]);
        }
      } else {
        optionals.push(config);
      }
    });
  }

  validateRequiredParamNoDefault(config) {
    if (config.required && config.default !== undefined) {
      this.logInvalidError('PARAM_REQUIRED_NO_DEFAULT', [config.label]);
    }
  }

  validateUniqueShortName(option, short, map) {
    if (map[short]) {
      this.logInvalidError('SHORT_DEFINED', [short, map[short]], option);
    }

    if (short.length !== 1) {
      this.logInvalidError('SHORT_INVALID_CHAR', [short], option);
    }
  }

  logFailureError(code, args) {
    this.logFailure(new ArgsError.ArgsError(code, args).message);
  }

  logFailure(message) {
    this.parseErrors.push(new ParseError.ParseError(message, this.arg, this.argIndex));
  }

  logInvalidError(code, args, option) {
    this.logInvalid(new ArgsError.ArgsError(code, args).message, option);
  }

  logInvalid(message, option) {
    this.validationErrors.push(new ValidationError.ValidationError(message, option));
  }

}

exports.Checker = Checker;
//# sourceMappingURL=Checker.js.map
