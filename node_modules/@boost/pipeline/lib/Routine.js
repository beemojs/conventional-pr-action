'use strict';

const _excluded = ["wrap", "workUnit"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var execa = require('execa');

var kebabCase = require('lodash/kebabCase');

var split = require('split');

var common = require('@boost/common');

var debug = require('@boost/debug');

var event = require('@boost/event');

var AggregatedPipeline = require('./AggregatedPipeline.js');

var ConcurrentPipeline = require('./ConcurrentPipeline.js');

var debug$1 = require('./debug.js');

var Pipeline = require('./Pipeline.js');

var PipelineError = require('./PipelineError.js');

var PooledPipeline = require('./PooledPipeline.js');

var WaterfallPipeline = require('./WaterfallPipeline.js');

var WorkUnit = require('./WorkUnit.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var execa__default = /*#__PURE__*/_interopDefault(execa);

var kebabCase__default = /*#__PURE__*/_interopDefault(kebabCase);

var split__default = /*#__PURE__*/_interopDefault(split);

class Routine extends WorkUnit.WorkUnit {
  /**
   * Called after `execa` was executed.
   * @category Events
   */

  /**
   * Called while a command is being executed.
   * @category Events
   */
  constructor(key, title, options) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    super(title, (context, value) => this.execute(context, value), options);
    this.debug = void 0;
    this.key = void 0;
    this.onCommand = new event.Event('command');
    this.onCommandData = new event.Event('command-data');
    this.monitorInstance = null;

    if (!key || key.length === 0 || typeof key !== 'string' && !Array.isArray(key)) {
      throw new PipelineError.PipelineError('ROUTINE_INVALID_KEY');
    }

    this.key = common.toArray(key).map(kebabCase__default['default']).join(':');
    this.debug = debug.createDebugger(['routine', this.key]);
    debug$1.debug('New routine created: %s (%s)', this.key, this.title);
  }
  /**
   * Execute a command with the given arguments and pass the results through a promise.
   */


  async executeCommand(command, args, options = {})
  /* infer */
  {
    const wrap = options.wrap,
          workUnit = options.workUnit,
          opts = _objectWithoutProperties(options, _excluded);

    const stream = execa__default['default'](command, args, opts);
    this.onCommand.emit([command, args]); // Push chunks to the reporter

    const unit = workUnit !== null && workUnit !== void 0 ? workUnit : this;

    const handler = line => {
      if (unit.isRunning()) {
        // Only capture the status when not empty
        if (line) {
          unit.statusText = line;
        }

        this.onCommandData.emit([command, line]);
      }
    };

    stream.stderr.pipe(split__default['default']()).on('data', handler);
    stream.stdout.pipe(split__default['default']()).on('data', handler); // Allow consumer to wrap functionality

    if (typeof wrap === 'function') {
      wrap(stream);
    }

    return stream;
  }
  /**
   * Create and return a `AggregatedPipeline`. This pipeline will execute all work units
   * in parallel without interruption. Returns an object with a list of errors and results
   * once all resolve.
   */


  createAggregatedPipeline(context, value) {
    return this.updateHierarchy(new AggregatedPipeline.AggregatedPipeline(context, value));
  }
  /**
   * Create and return a `ConcurrentPipeline`. This pipeline will execute all work units
   * in parallel. Returns a list of values once all resolve.
   */


  createConcurrentPipeline(context, value) {
    return this.updateHierarchy(new ConcurrentPipeline.ConcurrentPipeline(context, value));
  }
  /**
   * Create and return a `PooledPipeline`. This pipeline will execute a distinct set of work units
   * in parallel without interruption, based on a max concurrency, until all work units have ran.
   * Returns a list of errors and results once all resolve.
   */


  createPooledPipeline(context, value, options) {
    return this.updateHierarchy(new PooledPipeline.PooledPipeline(context, value, options));
  }
  /**
   * Create and return a `WaterfallPipeline`. This pipeline will execute each work unit one by one,
   * with the return value of the previous being passed to the next. Returns the final value once
   * all resolve.
   */


  createWaterfallPipeline(context, value) {
    return this.updateHierarchy(new WaterfallPipeline.WaterfallPipeline(context, value));
  }
  /**
   * Set the monitor to pass to nested pipelines.
   */


  setMonitor(monitor) {
    this.monitorInstance = monitor;
    return this;
  }
  /**
   * Update the hierarchical depth when creating a nested pipeline.
   */


  updateHierarchy(pipeline) {
    // eslint-disable-next-line no-param-reassign
    pipeline.depth = this.depth + 1;

    if (this.monitorInstance && pipeline instanceof Pipeline.Pipeline) {
      pipeline.monitor(this.monitorInstance);
    }

    return pipeline;
  }
  /**
   * Execute the current routine and return a new value.
   */


}

exports.Routine = Routine;
//# sourceMappingURL=Routine.js.map
