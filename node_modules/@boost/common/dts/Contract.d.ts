import { Blueprint, Predicates } from 'optimal';
import { Optionable } from './types';
export declare abstract class Contract<T extends object = {}> implements Optionable<T> {
    /** Validated and configured options. */
    readonly options: Readonly<Required<T>>;
    constructor(options?: T);
    /**
     * Set an options object by merging the new partial and existing options
     * with the defined blueprint, while running all validation checks.
     * Freeze and return the options object.
     *
     * ```ts
     * object.configure({ name: 'Boost' });
     *
     * object.configure((prevOptions) => ({
     * 	nestedObject: {
     * 		...prevOptions.nestedObject,
     * 		some: 'value',
     * 	},
     * }));
     * ```
     */
    configure(options?: Partial<T> | ((options: Required<T>) => Partial<T>)): Readonly<Required<T>>;
    /**
     * Define an `optimal` blueprint in which to validate and build the
     * options object passed to the constructor, or when manual setting.
     *
     * A boolean is passed as the 2nd argument to determine whether this is
     * validating on class instantiation (first time), or by calling
     * `configure()` (all other times).
     */
    abstract blueprint(predicates: Predicates, onConstruction?: boolean): Blueprint<object>;
}
//# sourceMappingURL=Contract.d.ts.map