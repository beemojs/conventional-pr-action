'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');

const path = require('path');

const url = require('url');

const React = require('react');

const glob = require('fast-glob');

const fs = require('fs-extra');

const cli = require('@boost/cli');

const common = require('@boost/common');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const path__default = /*#__PURE__*/_interopDefault(path);

const React__default = /*#__PURE__*/_interopDefault(React);

const glob__default = /*#__PURE__*/_interopDefault(glob);

const fs__default = /*#__PURE__*/_interopDefault(fs);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;

let ScaffoldCommand = (_dec = cli.Config('scaffold', 'Scaffold projects and packages with ease'), _dec2 = cli.Arg.Flag('Overwrite files if they already exist', {
  short: 'f'
}), _dec3 = cli.Arg.String('Package manager to install dependencies with', {
  choices: ['npm', 'pnpm', 'yarn']
}), _dec4 = cli.Arg.String('Folder in which packages will be located (monorepo only)'), _dec5 = cli.Arg.Flag('Skip installation of npm dependencies'), _dec6 = cli.Arg.String('Default template to scaffold', {
  choices: ['monorepo', 'monorepo-package', 'polyrepo', 'polyrepo-package']
}), _dec7 = cli.Arg.Params({
  label: 'dest',
  description: 'Destination to copy template to',
  type: 'string',
  required: true
}), _dec(_class = (_class2 = class ScaffoldCommand extends cli.Command {
  constructor(...args) {
    super(...args);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "force", _descriptor, this);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "packageManager", _descriptor2, this);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "packagesFolder", _descriptor3, this);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "skipInstall", _descriptor4, this);

    _rollupPluginBabelHelpers.initializerDefineProperty(this, "template", _descriptor5, this);

    this.dest = '';
    this.destDir = '';
  }

  async run(dest) {
    this.dest = dest;
    this.destDir = path__default.default.join(process.cwd(), dest);

    const _await$Promise$resolv = await Promise.resolve().then(() => require('../components/Scaffold/index.js')),
          Scaffold = _await$Promise$resolv.Scaffold;

    return /*#__PURE__*/React__default.default.createElement(Scaffold, {
      defaultTemplate: this.template,
      onComplete: params => this.scaffold(params)
    });
  }

  async scaffold(params) {
    switch (params.template) {
      default:
      case 'monorepo':
        return this.scaffoldMonorepo(params);

      case 'monorepo-package':
        return this.scaffoldMonorepoPackage(params);

      case 'polyrepo':
        return this.scaffoldPolyrepo(params);

      case 'polyrepo-package':
        return this.scaffoldPolyrepoPackage(params);
    }
  }

  async scaffoldMonorepo(params) {
    await this.checkExistingInfrastructure('monorepo');
    await this.copyFilesFromTemplate('base', this.destDir, params);
    await this.copyFilesFromTemplate('monorepo', this.destDir, _objectSpread(_objectSpread({}, params), {}, {
      packagesFolder: this.packagesFolder
    }));
    await this.installDependencies('monorepo');

    try {
      await fs__default.default.mkdir(path__default.default.join(this.destDir, this.packagesFolder));
    } catch {// Ignore
    }
  }

  async scaffoldMonorepoPackage(params) {
    const packagesDir = path__default.default.join(this.destDir, this.packagesFolder);

    if (!fs__default.default.existsSync(packagesDir)) {
      throw new Error(`Cannot create a monorepo package as the monorepo infrastructure has not been scaffolded. Please run \`packemon scaffold --template monorepo ${this.dest}\`.`);
    }

    const packageName = params.packageName;
    const folderName = packageName.startsWith('@') ? packageName.split('/')[1] : packageName;
    const packageDir = path__default.default.join(packagesDir, folderName);
    const packagePath = `${this.packagesFolder}/${folderName}`;
    await this.copyFilesFromTemplate('package', packageDir, params);
    await this.copyFilesFromTemplate('monorepo-package', packageDir, _objectSpread(_objectSpread({}, params), {}, {
      packagePath
    }));
    await this.addProjectReference(packagePath);
  }

  async scaffoldPolyrepo(params) {
    await this.checkExistingInfrastructure('polyrepo');
    await this.copyFilesFromTemplate('base', this.destDir, params);
    await this.copyFilesFromTemplate('polyrepo', this.destDir, params);
    await this.installDependencies('polyrepo');
  }

  async scaffoldPolyrepoPackage(params) {
    // Since a polyrepo and package are the same thing, scaffold the infra automatically
    await this.scaffoldPolyrepo(params);
    await this.copyFilesFromTemplate('package', this.destDir, params);
  }

  async addProjectReference(packagePath) {
    const tsconfigPath = path__default.default.join(this.destDir, 'tsconfig.json');
    const tsconfig = await this.loadJsonConfig(tsconfigPath);

    if (!Array.isArray(tsconfig.references)) {
      tsconfig.references = [];
    }

    tsconfig.references.push({
      path: packagePath
    }, {
      path: path__default.default.join(packagePath, 'tests')
    });
    tsconfig.references.sort((a, b) => a.path.localeCompare(b.path));
    await fs__default.default.writeJson(tsconfigPath, tsconfig, {
      spaces: 2
    });
  }

  async installDependencies(type) {
    if (this.skipInstall) {
      return;
    }

    const args = ['@types/jest', '@types/node', 'eslint-config-beemo', 'eslint', 'jest-preset-beemo', 'jest', 'packemon', 'prettier-config-beemo', 'prettier', 'tsconfig-beemo', 'typescript'];

    switch (this.packageManager) {
      default:
      case 'yarn':
        {
          const version = Number.parseFloat((await this.executeCommand('yarn', ['-v'])).stdout);
          args.unshift('add', '--dev', type === 'monorepo' && version < 2 ? '-W' : '');
          break;
        }

      case 'pnpm':
        args.unshift('add', '--save-dev', type === 'monorepo' ? '-W' : '');
        break;

      case 'npm':
        args.unshift('install', '--save-dev');
        break;
    }

    await this.executeCommand(this.packageManager, args.filter(Boolean), {
      cwd: this.destDir
    });
  }

  async checkExistingInfrastructure(type) {
    const packagePath = path__default.default.join(this.destDir, 'package.json');

    if (!fs__default.default.existsSync(packagePath)) {
      return;
    }

    const pkg = await this.loadJsonConfig(packagePath);

    if (pkg.infra !== type) {
      throw new Error(`Cannot scaffold ${type} infrastructure, as destination has already been setup as a ${pkg.infra}.`);
    }
  }

  async copyFile(fromTemplate, toDest, params) {
    const isPackage = fromTemplate.endsWith('package.json') && toDest.endsWith('package.json'); // Dont overwrite existing files (except package.json)

    if (fs__default.default.existsSync(toDest) && !this.force && !isPackage) {
      return;
    }

    const toDir = path__default.default.dirname(toDest);

    if (!fs__default.default.existsSync(toDir)) {
      await fs__default.default.ensureDir(toDir);
    } // Interpolate params into string content


    let content = await fs__default.default.readFile(fromTemplate, 'utf8');
    Object.entries(params).forEach(([key, value]) => {
      content = content.replace(new RegExp(`<${key}>`, 'g'), String(value));
    }); // Instead of overwriting package.json, we want to merge them

    if (fs__default.default.existsSync(toDest) && isPackage) {
      const prevContent = await this.loadJsonConfig(toDest);
      const nextContent = common.json.parse(content);
      await fs__default.default.writeJson(toDest, _objectSpread(_objectSpread({}, prevContent), nextContent), {
        spaces: 2
      }); // Otherwise write content as a string
    } else {
      await fs__default.default.writeFile(toDest, content, 'utf8');
    }
  }

  async copyFilesFromTemplate(template, destDir, params) {
    // @ts-expect-error URL type mismatch
    const templateDir = url.fileURLToPath(new URL(`../../templates/${template}`, typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('commands/Scaffold.js', document.baseURI).href));
    const files = await glob__default.default('**/*', {
      absolute: false,
      dot: true,
      cwd: templateDir
    });
    return Promise.all(files.map(file => this.copyFile(path__default.default.join(templateDir, file), path__default.default.join(destDir, file), _objectSpread({}, params))));
  }

  async loadJsonConfig(filePath) {
    // Supports comments
    return common.json.parse(await fs__default.default.readFile(filePath, 'utf8'));
  }

}, (_descriptor = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "force", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor2 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "packageManager", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'yarn';
  }
}), _descriptor3 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "packagesFolder", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'packages';
  }
}), _descriptor4 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "skipInstall", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor5 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "template", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "run", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "run"), _class2.prototype)), _class2)) || _class);
exports.ScaffoldCommand = ScaffoldCommand;
//# sourceMappingURL=Scaffold.js.map
