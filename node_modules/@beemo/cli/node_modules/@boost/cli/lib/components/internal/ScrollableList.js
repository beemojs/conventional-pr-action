'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var React = require('react');

var ink = require('ink');

require('../../hooks/index.js');

var translate = require('../../translate.js');

var Style = require('../Style.js');

var useDimensions = require('../../hooks/useDimensions.js');

function _interopDefault(e) {
  return e && e.__esModule ? e : {
    'default': e
  };
}

var React__default = /*#__PURE__*/_interopDefault(React);

function calculateIndexes(maxIndex, currentIndex, limit, scrollType) {
  let startIndex = 0;
  let endIndex = 0;

  switch (scrollType) {
    // Current index is placed at the top, while navigation
    // always displays up to the maximum limit, and wraps around edges.
    case 'cycle':
      {
        startIndex = Math.min(Math.max(currentIndex, 0), maxIndex);
        endIndex = startIndex + limit - 1;

        if (endIndex > maxIndex) {
          endIndex = (endIndex - maxIndex - 1) * -1;
        }

        break;
      }
    // Current index is placed within the middle of the limit,
    // while navigation caps at either edge.

    case 'overflow':
    default:
      {
        const beforeLimit = Math.floor(limit / 2);
        const afterLimit = Math.floor(limit / 2) - (limit % 2 === 0 ? 1 : 0);

        if (currentIndex <= beforeLimit) {
          startIndex = 0;
          endIndex = limit - 1;
        } else if (currentIndex > maxIndex - afterLimit) {
          startIndex = maxIndex - limit + 1;
          endIndex = maxIndex;
        } else {
          startIndex = currentIndex - beforeLimit;
          endIndex = currentIndex + afterLimit;
        }

        break;
      }
  }

  return {
    endIndex,
    startIndex
  };
}

function truncateList(items, startIndex, endIndex) {
  let list;
  let leading = [];
  let trailing = []; // Wraps past the end

  if (endIndex <= 0) {
    list = [...items.slice(startIndex), ...items.slice(0, Math.abs(endIndex) + 1)];
    trailing = items.slice(Math.abs(endIndex) + 1, startIndex); // Wraps past the beginning
  } else if (startIndex < 0) {
    list = [...items.slice(Math.abs(startIndex)), ...items.slice(0, endIndex + 1)];
    trailing = items.slice(endIndex + 1, Math.abs(startIndex)); // In the middle
  } else {
    list = items.slice(startIndex, endIndex + 1);
    leading = items.slice(0, startIndex);
    trailing = items.slice(endIndex + 1);
  }

  return {
    leading,
    list,
    trailing
  };
}

function countEnabledItems(items) {
  return items.filter(i => {
    if ('disabled' in i) {
      return !i.disabled;
    }

    if ('divider' in i) {
      return !i.divider;
    }

    return true;
  }).length;
}

function renderOverflowLabel(value, count) {
  if (typeof value === 'string') {
    return value;
  }

  if (typeof value === 'function') {
    return value(count);
  }

  return undefined;
}

function ScrollableList({
  currentIndex,
  items,
  limit,
  overflowAfterLabel,
  overflowBeforeLabel,
  renderItem,
  rowHeight = 1,
  scrollType = 'overflow'
}) {
  var _renderOverflowLabel, _renderOverflowLabel2;

  const _useDimensions$useDim = useDimensions.useDimensions(),
        viewportHeight = _useDimensions$useDim.height;

  const isOverflow = scrollType === 'overflow'; // We dont want the list to overflow past the terminal size,
  // so cap it to max number of rows that will fit in the viewport
  // eslint-disable-next-line no-magic-numbers

  const padding = isOverflow ? 4 : 2;
  const maxLimit = Math.floor(Math.min(limit !== null && limit !== void 0 ? limit : viewportHeight, viewportHeight - padding) / rowHeight); // Slice the list according to the chosen scroll type

  const _calculateIndexes = calculateIndexes(items.length - 1, currentIndex, maxLimit, scrollType),
        startIndex = _calculateIndexes.startIndex,
        endIndex = _calculateIndexes.endIndex;

  const _React$useMemo = React.useMemo(() => truncateList(items, startIndex, endIndex), [endIndex, items, startIndex]),
        leading = _React$useMemo.leading,
        list = _React$useMemo.list,
        trailing = _React$useMemo.trailing;

  const leadingCount = countEnabledItems(leading);
  const trailingCount = countEnabledItems(trailing);
  return /*#__PURE__*/React__default['default'].createElement(ink.Box, {
    flexDirection: "column"
  }, leadingCount > 0 && isOverflow && /*#__PURE__*/React__default['default'].createElement(ink.Box, {
    marginLeft: 2
  }, /*#__PURE__*/React__default['default'].createElement(Style.Style, {
    type: "muted"
  }, (_renderOverflowLabel = renderOverflowLabel(overflowBeforeLabel, leadingCount)) !== null && _renderOverflowLabel !== void 0 ? _renderOverflowLabel : translate.msg('prompt:scrollOverflowBefore', {
    count: leadingCount
  }))), list.map(item => renderItem(item)), trailingCount > 0 && isOverflow && /*#__PURE__*/React__default['default'].createElement(ink.Box, {
    marginLeft: 2
  }, /*#__PURE__*/React__default['default'].createElement(Style.Style, {
    type: "muted"
  }, (_renderOverflowLabel2 = renderOverflowLabel(overflowAfterLabel, trailingCount)) !== null && _renderOverflowLabel2 !== void 0 ? _renderOverflowLabel2 : translate.msg('prompt:scrollOverflowAfter', {
    count: trailingCount
  }))));
}

exports.ScrollableList = ScrollableList;
exports.calculateIndexes = calculateIndexes;
exports.truncateList = truncateList;
//# sourceMappingURL=ScrollableList.js.map
