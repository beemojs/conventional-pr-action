import { ArgList, PrimitiveType } from '@boost/args';
import { Contract } from '@boost/common';
import { Event } from '@boost/event';
import { Commandable, CommandMetadata, CommandPath, GlobalOptions, ProxyCommandConfig, ProxyCommandRunner } from './types';
export declare abstract class CommandManager<Options extends object = {}> extends Contract<Options> {
    /**
     * Called after a command has been registered.
     * @category Events
     */
    readonly onAfterRegister: Event<[string, Commandable<any, any[]>], string>;
    /**
     * Called before a command has been registered.
     * @category Events
     */
    readonly onBeforeRegister: Event<[string, Commandable<any, any[]>], string>;
    protected commands: CommandMetadata['commands'];
    protected commandAliases: Record<string, string>;
    /**
     * Return a command by registered path, or `null` if not found.
     */
    getCommand<O extends object = {}, P extends PrimitiveType[] = ArgList>(path: CommandPath): Commandable<O, P> | null;
    /**
     * Return a list of all registered command paths (including aliases).
     */
    getCommandPaths(): CommandPath[];
    /**
     * Register a command and its canonical path (must be unique),
     * otherwise an error is thrown.
     */
    register(command: Commandable): this;
    register<O extends object, P extends PrimitiveType[]>(path: CommandPath, config: ProxyCommandConfig<O, P>, runner: ProxyCommandRunner<O, P>): this;
    /**
     * Check that a command path is valid.
     */
    protected checkPath(path: CommandPath): void;
    protected abstract createProxyCommand<O extends GlobalOptions, P extends PrimitiveType[]>(path: CommandPath, config: ProxyCommandConfig<O, P>, runner: ProxyCommandRunner<O, P>): Commandable<O, P>;
}
//# sourceMappingURL=CommandManager.d.ts.map