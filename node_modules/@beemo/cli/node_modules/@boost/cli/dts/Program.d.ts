import React from 'react';
import { ArgList, Arguments, Argv, PrimitiveType } from '@boost/args';
import { Blueprint, Predicates } from '@boost/common';
import { Event } from '@boost/event';
import { LoggerFunction } from '@boost/log';
import { Command } from './Command';
import { CommandManager } from './CommandManager';
import { Categories, Commandable, CommandPath, ExitCode, GlobalOptions, Middleware, MiddlewareArguments, ProgramBootstrap, ProgramOptions, ProgramStreams, ProxyCommandConfig, ProxyCommandRunner, RunResult } from './types';
export declare class Program extends CommandManager<ProgramOptions> {
    /**
     * Called after a component has rendered.
     * @category Events
     */
    readonly onAfterRender: Event<unknown[], string>;
    /**
     * Called after the program and command have been ran.
     * @category Events
     */
    readonly onAfterRun: Event<[(Error | undefined)?], string>;
    /**
     * Called after a command has run but before a component will render.
     * @category Events
     */
    readonly onBeforeRender: Event<[RunResult], string>;
    /**
     * Called before the program and command will run.
     * @category Events
     */
    readonly onBeforeRun: Event<[Argv], string>;
    /**
     * Called when a command has been found after parsing argv.
     * @category Events
     */
    readonly onCommandFound: Event<[Argv, string, Commandable<any, any[]>], string>;
    /**
     * Called when a command wasn't found after parsing argv.
     * @category Events
     */
    readonly onCommandNotFound: Event<[Argv, string], string>;
    /**
     * Called when the exit() handler is executed but before the process exits.
     * @category Events
     */
    readonly onExit: Event<[string, number], string>;
    /**
     * Called when the help menu is rendered.
     * @category Events
     */
    readonly onHelp: Event<[(string | undefined)?], string>;
    readonly streams: ProgramStreams;
    protected commandLine: string;
    protected logger: LoggerFunction;
    protected middlewares: Middleware[];
    protected rendering: boolean;
    protected sharedCategories: Categories;
    protected standAlone: CommandPath;
    private errBuffer;
    private outBuffer;
    constructor(options: ProgramOptions, streams?: ProgramStreams);
    blueprint(predicates: Predicates): Blueprint<ProgramOptions>;
    /**
     * Define option and command categories to supply to the running command,
     * or the program itself.
     */
    categories(categories: Categories): this;
    /**
     * Register a command and its canonical path as the default command.
     * A default command should be used when stand-alone binary is required.
     */
    default(command: Commandable): this;
    /**
     * Exit the program with an error code.
     * Should be called within a command or component.
     */
    exit: (error?: string | Error | undefined, errorCode?: number | undefined) => never;
    /**
     * Define a middleware function to apply to the argv list or args object.
     */
    middleware(middleware: Middleware): this;
    /**
     * Parse the arguments list according to the number of commands that have been registered.
     */
    parse<O extends GlobalOptions, P extends PrimitiveType[] = ArgList>(argv: Argv): Arguments<O, P>;
    /**
     * Render a React element with Ink and output to the configured streams.
     */
    renderElement(element: React.ReactElement): Promise<void>;
    /**
     * Run the program in the following steps:
     * - Apply middleware to argv list.
     * - Parse argv into an args object (of options, params, etc).
     * - Determine command to run, or fail.
     * - Run command and render output.
     * - Return exit code.
     */
    run(argv: Argv, bootstrap?: ProgramBootstrap, rethrow?: boolean): Promise<ExitCode>;
    /**
     * Run the program and also set the process exit code.
     */
    runAndExit(argv: Argv, bootstrap?: ProgramBootstrap): Promise<ExitCode>;
    /**
     * Render the index screen when no args are passed.
     * Should include banner, header, footer, and command (if applicable).
     */
    protected createIndex(): Promise<React.ReactElement>;
    /**
     * Loop through all middleware to modify the argv list
     * and resulting args object.
     */
    protected applyMiddlewareAndParseArgs(argv: Argv): MiddlewareArguments | Promise<MiddlewareArguments>;
    /**
     * Create a proxy command using the `Command` class as the super class.
     */
    protected createProxyCommand<O extends GlobalOptions, P extends PrimitiveType[]>(path: CommandPath, config: ProxyCommandConfig<O, P>, runner: ProxyCommandRunner<O, P>): Command<O, P>;
    /**
     * Render the result of a command's run to the defined stream.
     * If a string has been returned, write it immediately.
     * If a React component, render with Ink and wait for it to finish.
     */
    protected render(result: RunResult, exitCode?: ExitCode): Promise<ExitCode>;
    /**
     * Render an error and warnings menu based on the list provided.
     * If argument parser or validation errors are found, treat them with special logic.
     */
    protected renderErrors(errors: Error[]): Promise<ExitCode>;
    /**
     * Internal run that does all the heavy lifting and parsing,
     * while the public run exists to catch any unexpected errors.
     */
    protected runAndRender(argv: Argv): Promise<ExitCode>;
    /**
     * Deeply register all commands so that we can easily access it during parse.
     */
    private handleAfterRegister;
    /**
     * Check for default and non-default command mixing.
     */
    private handleBeforeRegister;
}
//# sourceMappingURL=Program.d.ts.map